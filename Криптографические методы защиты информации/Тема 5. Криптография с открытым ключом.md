02.03.2023

Лекция 4

---

# 1. Основные принципы
- В симметричной криптографии каждая из переписывающихся сторон должна иметь копию общего секретного ключа, что создает сложнейшую проблему управления ключами
- В криптосистемах с открытым ключом используется два ключа: открытый и секретный
- Открытый ключ может быть опубликован в справочнике наряду с именем пользователя. В результате любой желающий может зашифровать с его помощью свое письмо и послать закрытую информацию владельцу соответствующего секретного ключа
- Расшифровать посланное сообщение сможет только тот, у кого есть секретный ключ
- Причина работоспособности таких криптосистем: существует односторонняя математическая связь между открытым и секретным ключами, так что
	- информация об открытом ключе никак не помогает восстановить секретный ключ
	- владение секретным ключом обеспечивает возможность расшифровывать сообщения, зашифрованные открытым ключом
- Таким образом, необходимо найти математическое преобразование, которое было бы сложно обратить (без знания специальной секретной информации) на стадии расшифрования
- Преобразование, обладающее указанным свойством, называется односторонней функцией

Односторонней называется функция $F: X \rightarrow Y$, обладающая двумя свойствами:
- Существует полиномиальный алгоритм вычисления значений $F(x)$
- Не существует полиномиального алгоритма обращения функции $F$ (то есть решения уравнения $F(x) = y$ относительно $x$, $x \in X, y \in Y$)

Вопрос о существовании односторонних функций пока открыт

Функцией с секретом $k$ (функция-ловушка) называется функция $F_k: X \rightarrow Y$, зависящая от параметра $k$ и обладающая тремя свойствами:
- Существует полиномиальный алгоритм вычисления значения $F_k(x)$ для любых $k$ и $x$
- Не существует полиномиального алгоритма обращения $F_k$ при неизвестном $k$
- Существует полиномиальный алгоритм обращения $F_k$ при известном $k$

Гипотеза о существовании односторонних функций:
- Задача разложения целых чисел на множители
- Проблема вычисления дискретных логарифмов
- Вычисления квадратных корней по модулю составного числа

Однако все они являются односторонними только в вычислительном отношении, то есть имея достаточно большие компьютерные мощности, их вполне можно обратить, причем быстрее, чем найти секретный ключ в результате полного перебора

Применение односторонних функций в криптографии позволяет:
- Организовать обмен шифрованными сообщениями с использованием только открытых каналов связи, то есть отказаться от секретных каналов связи для обмена ключами
- Включить в задачу вскрытия шифра трудную математическую задачу и тем самым повысить обоснованность стойкости шифра
- Решать новые криптографические задачи, отличные от шифрования (электронная цифровая подпись и другие)

# 1. История криптосистем с открытым ключом

Идея криптографии с открытым ключом впервые появились в 1976 году в революционной работе Диффи и Хеллмана "Новые направления в криптографии"

## 1.1. Система с открытым ключом Диффи-Хеллмана
Построим систему связи с абонентами $A, B, C, \ldots$

1. Для организации этой системы выбирают большое простое число $P$ и некоторое $G$
- $1 < G < P - 1$
- Все числа из множества $\{1, 2, \ldots, P - 1\}$ могут быть представлены как различные степени $G$ по $\mod P$

На практике выбор этих чисел может быть следующим:

$P$ выбирают вида $P = 2Q + 1$, где $Q$ также простое число, тогда в качестве $G$ выбирают любое число удовлетворяющее условиям:
- $1 < G < P - 1$
- $G^Q \mod P \neq 1$

2. Абоненты $A, B, C, \ldots$ выбирают большие числа $X_A, X_B, X_C, \ldots$, которые хранят в секрете (получают используя датчики случайных чисел)
3. Каждый из абонентов вычисляет открытый ключ
$$\matrix{y_A = G^{X_A} \mod P \\ y_B = G^{X_B} \mod P \\ y_C = G^{X_C} \mod P \\ \cdots}$$

В результате получаем таблицу ключей пользователей

| Абоненты | Секретный ключ (знает только конкретный пользователь) | Открытый ключ | Параметры системы |
|-|-|-|-|
|$A$|$X_A$|$y_A$|$P, G$|
|$B$|$X_B$|$y_B$|$P, G$|
|$C$|$X_C$|$y_C$|$P, G$|
|$\cdots$|$\cdots$|$\cdots$|$P, G$|

4. Допустим абонент $A$ решил организовать связь с абонентом $B$, при этом им обоим доступна вся информация столбцов 1, 3 и 4 (во 2-ом столбце им доступны только их секретные ключи)

Абонент $A$ оповещает об этом $B$ и они вырабатывают одинаковый общий секретный ключ по следующему алгоритму

$$\matrix{A: Z_{AB} = (y_B)^{X_A} \mod P \\ B: Z_{BA} = (y_A)^{X_B} \mod P}$$

Доказательство того, что ключи выработанные абонентами $A$ и $B$ совпадают:

$Z_{AB} = (y_B)^{X_A} \mod P = (G^{X_B})^{X_A} \mod P = (G^{X_A})^{X_B} \mod P = (y_A)^{X_B} \mod P = Z_{BA}$

## 1.2. Система шифрования с открытым ключом RSA
Спустя год была опубликована первая криптосистема с открытым ключом - RSA

Построим систему связи с абонентами $A, B, C, \ldots$

1. Для организации этой системы каждый абонент независимо друг от друга выбирает два больших простых числа $P$ и $Q$
2. Каждый абонент вычисляет свои числа:
- Число $n = PQ$
- Функцию Эйлера $\varphi(n) = (P - 1)(Q - 1)$
3. Каждый абонент выбирает свое число $e$
- $1 < e < \varphi(n)$
- $\gcd(e, \varphi(n)) = 1$

Пары $(e_A, n_A), (e_B, n_B), (e_C, n_C), \ldots$ считаются открытыми ключами абонентов $A, B, C, \ldots$

4. Затем каждый абонент группы выбирает свое секретное число (секретный ключ) путем решения уравнений
$$\matrix{e_A \cdot d_A = 1 \mod \varphi(n_A) \\ e_B \cdot d_B = 1 \mod \varphi(n_B) \\ e_C \cdot d_C = 1 \mod \varphi(n_C) \\ \cdots}$$

Пары $(d_A, n_A), (d_B, n_B), (d_C, n_C), \ldots$ считаются секретными ключами абонентов $A, B, C, \ldots$

Ключи пользователей в системе RSA

| Абонент | Секретный ключ | Открытый ключ |
|-|-|-|
|$A$|$(d_A, n_A)$|$(e_A, n_A)$|
|$B$|$(d_B, n_B)$|$(e_B, n_B)$|
|$C$|$(d_C, n_C)$|$(e_C, n_C)$|
|$\cdots$|$\cdots$|$\cdots$|

Алгоритм передачи сообщения от $A$ к $B$:
1. Абонент $A$ вычисляет число $S = M^{e_B} \mod n_B$, где $M$ - сообщение ($M < n$), $S$ - шифрованный текст, и передает $S$ абоненту $B$
2. Абонент $B$ получив число $S$ расшифровывает сообщение $S^{d_B} \mod n_B = M$

## 1.3. Шифр Шамира
Пусть абоненты $A$ и $B$ желают вести конфиденциальную переписку

Пусть абонент $A$ выбирает большое простое число $P$ и передает его абоненту $B$. Затем каждый из них выбирает числа, удовлетворяющих условиям:
$$\matrix{A: c_A \cdot d_A = 1 \mod (P - 1) \\ B: c_B \cdot d_B = 1 \mod (P - 1)}$$

При этом при кодировании каждого блока $M_k$ следует выбирать случайные пары $(c_A, d_A)$ и $(c_B, d_B)$ - в противном случае надежность системы понижается

Алгоритм:
1. Абонент $A$ вычисляет число $x_1 = M^{c_A} \mod P$ и пересылает его к абоненту $B$
2. Абонент $B$ получив число $x_1$ вычисляет свое число $x_2 = x_1^{c_B} \mod P$ и передает его абоненту $A$
3. Абонент $A$ получив число $x_2$ вычисляет свое число $x_3 = x_2^{d_A} \mod P$ и передает его абоненту $B$
4. Абонент $B$ получив число $x_3$ вычисляет свое число $x_4 = x_3^{d_B} \mod P = M$, которое равно сообщению, посланное абонентом $A$

# Криптосистема RSA (слабые моменты)
1. Незашифрованные блоки
2. Ключи эквивалентные ключу расшифрования
3. Криптоанализ RSA

Неподвижной (инвариантной) точкой отображения $M^E \mod n$ называется число $M \in \{0, 1, \ldots, n - 1\}$, оставляемое этим отображением на месте, то есть $M^E = M \mod n$

Теорема 1. Число неподвижных точке отображения $M^E \mod n$ равно $d = (d_1 + 1)(d_2 + 1)$, где $d_1 = \gcd(E - 1, p - 1)$ и $d_2 = \gcd(E - 1, q - 1)$

Теорема 2. Количество ключей расшифрования равно $d^* = \gcd(p - 1, q - 1)$

На основании теоремы 2 любое число из множества $\{D + m cdot L(n) \mod \varphi(n), m \in \{0, 1, 2, \ldots, d^* - 1\}\}$, $L(n) = \lcm(p - 1, q - 1)$, $D \cdot E = 1 \mod \varphi(n)$ являются ключом расшифрования

## Криптоанализ криптосистемы RSA
### 1. Метод Ферма
Если делители $p$ и $q$ числа $N$ близки друг к другу

Пусть $p > q$, тогда $N = \left(\frac{p + q}{2}\right)^2 - \left(\frac{p - q}{2}\right)^2$

Пусть $t = \frac{p+q}{2}$, $s = \frac{p - q}{2}$, так как последняя величина небольшая, то и $t - \sqrt N$ также является небольшим числом и $t^2 - N$ является полным квадратом. Переберем все числа $t > \sqrt N$ и проверим на выполнение условия $t^2 - N = a^2$

Далее нахождение $p$ и $q$ не представляет большого труда

### 2. Метод повторного шифрования
Рассмотрим последовательность $y_1 = y = x^e \mod N, y_2 = y_1^e \mod N, \ldots, y_s = y_{s-1}^e \mod N$

Так как $(e, \varphi(N)) = 1$, то $\exists k \in Z, k > 0: e^k = 1 \mod \vdrphi(N)$ и $y_k = y_{k-1}^e = y \mod N$, следовательно $y_{k-1} = x$

### 3. Метод бесключевого чтения
Пусть два пользователя выбрали одинаковый модуль $N$ и разные экспоненты $e_1$ и $e_2$. Третий пользователь посылает им некое циркулярное сообщение $x$, то криптоаналитик может получить в свое распоряжение два шифрованных текста $y_1 = x^{e_1} \mod N$ и $y_2 = x^{e_2} \mod N$

В этом случае криптоаналитик может получить исходное открытое сообщение, используя расширенный алгоритм Евклида, выполнив следующую последовательность действий:
- Находим $r, s$ такие, что $r \cdot e_1 + s \cdot e_2 = 1$
- Получаем открытое сообщение $y_1^r \cdot y_2^s = x^{r\cdot e_1 + s \cdot e_2} = x$

---

09.03.2023

Лекция 5

---

# Криптосистемы основанные на задаче RSA