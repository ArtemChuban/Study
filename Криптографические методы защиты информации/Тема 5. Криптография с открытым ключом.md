02.03.2023

Лекция 4

---

# 1. Основные принципы
- В симметричной криптографии каждая из переписывающихся сторон должна иметь копию общего секретного ключа, что создает сложнейшую проблему управления ключами
- В криптосистемах с открытым ключом используется два ключа: открытый и секретный
- Открытый ключ может быть опубликован в справочнике наряду с именем пользователя. В результате любой желающий может зашифровать с его помощью свое письмо и послать закрытую информацию владельцу соответствующего секретного ключа
- Расшифровать посланное сообщение сможет только тот, у кого есть секретный ключ
- Причина работоспособности таких криптосистем: существует односторонняя математическая связь между открытым и секретным ключами, так что
	- информация об открытом ключе никак не помогает восстановить секретный ключ
	- владение секретным ключом обеспечивает возможность расшифровывать сообщения, зашифрованные открытым ключом
- Таким образом, необходимо найти математическое преобразование, которое было бы сложно обратить (без знания специальной секретной информации) на стадии расшифрования
- Преобразование, обладающее указанным свойством, называется односторонней функцией

Односторонней называется функция $F: X \rightarrow Y$, обладающая двумя свойствами:
- Существует полиномиальный алгоритм вычисления значений $F(x)$
- Не существует полиномиального алгоритма обращения функции $F$ (то есть решения уравнения $F(x) = y$ относительно $x$, $x \in X, y \in Y$)

Вопрос о существовании односторонних функций пока открыт

Функцией с секретом $k$ (функция-ловушка) называется функция $F_k: X \rightarrow Y$, зависящая от параметра $k$ и обладающая тремя свойствами:
- Существует полиномиальный алгоритм вычисления значения $F_k(x)$ для любых $k$ и $x$
- Не существует полиномиального алгоритма обращения $F_k$ при неизвестном $k$
- Существует полиномиальный алгоритм обращения $F_k$ при известном $k$

Гипотеза о существовании односторонних функций:
- Задача разложения целых чисел на множители
- Проблема вычисления дискретных логарифмов
- Вычисления квадратных корней по модулю составного числа

Однако все они являются односторонними только в вычислительном отношении, то есть имея достаточно большие компьютерные мощности, их вполне можно обратить, причем быстрее, чем найти секретный ключ в результате полного перебора

Применение односторонних функций в криптографии позволяет:
- Организовать обмен шифрованными сообщениями с использованием только открытых каналов связи, то есть отказаться от секретных каналов связи для обмена ключами
- Включить в задачу вскрытия шифра трудную математическую задачу и тем самым повысить обоснованность стойкости шифра
- Решать новые криптографические задачи, отличные от шифрования (электронная цифровая подпись и другие)

# 1. История криптосистем с открытым ключом

Идея криптографии с открытым ключом впервые появились в 1976 году в революционной работе Диффи и Хеллмана "Новые направления в криптографии"

## 1.1. Система с открытым ключом Диффи-Хеллмана
Построим систему связи с абонентами $A, B, C, \ldots$

1. Для организации этой системы выбирают большое простое число $P$ и некоторое $G$
- $1 < G < P - 1$
- Все числа из множества $\{1, 2, \ldots, P - 1\}$ могут быть представлены как различные степени $G$ по $\mod P$

На практике выбор этих чисел может быть следующим:

$P$ выбирают вида $P = 2Q + 1$, где $Q$ также простое число, тогда в качестве $G$ выбирают любое число удовлетворяющее условиям:
- $1 < G < P - 1$
- $G^Q \mod P \neq 1$

2. Абоненты $A, B, C, \ldots$ выбирают большие числа $X_A, X_B, X_C, \ldots$, которые хранят в секрете (получают используя датчики случайных чисел)
3. Каждый из абонентов вычисляет открытый ключ
$$\matrix{y_A = G^{X_A} \mod P \\ y_B = G^{X_B} \mod P \\ y_C = G^{X_C} \mod P \\ \cdots}$$

В результате получаем таблицу ключей пользователей

| Абоненты | Секретный ключ (знает только конкретный пользователь) | Открытый ключ | Параметры системы |
|-|-|-|-|
|$A$|$X_A$|$y_A$|$P, G$|
|$B$|$X_B$|$y_B$|$P, G$|
|$C$|$X_C$|$y_C$|$P, G$|
|$\cdots$|$\cdots$|$\cdots$|$P, G$|

4. Допустим абонент $A$ решил организовать связь с абонентом $B$, при этом им обоим доступна вся информация столбцов 1, 3 и 4 (во 2-ом столбце им доступны только их секретные ключи)

Абонент $A$ оповещает об этом $B$ и они вырабатывают одинаковый общий секретный ключ по следующему алгоритму

$$\matrix{A: Z_{AB} = (y_B)^{X_A} \mod P \\ B: Z_{BA} = (y_A)^{X_B} \mod P}$$

Доказательство того, что ключи выработанные абонентами $A$ и $B$ совпадают:

$Z_{AB} = (y_B)^{X_A} \mod P = (G^{X_B})^{X_A} \mod P = (G^{X_A})^{X_B} \mod P = (y_A)^{X_B} \mod P = Z_{BA}$

## 1.2. Система шифрования с открытым ключом RSA
Спустя год была опубликована первая криптосистема с открытым ключом - RSA

Построим систему связи с абонентами $A, B, C, \ldots$

1. Для организации этой системы каждый абонент независимо друг от друга выбирает два больших простых числа $P$ и $Q$
2. Каждый абонент вычисляет свои числа:
- Число $n = PQ$
- Функцию Эйлера $\varphi(n) = (P - 1)(Q - 1)$
3. Каждый абонент выбирает свое число $e$
- $1 < e < \varphi(n)$
- $\gcd(e, \varphi(n)) = 1$

Пары $(e_A, n_A), (e_B, n_B), (e_C, n_C), \ldots$ считаются открытыми ключами абонентов $A, B, C, \ldots$

4. Затем каждый абонент группы выбирает свое секретное число (секретный ключ) путем решения уравнений
$$\matrix{e_A \cdot d_A = 1 \mod \varphi(n_A) \\ e_B \cdot d_B = 1 \mod \varphi(n_B) \\ e_C \cdot d_C = 1 \mod \varphi(n_C) \\ \cdots}$$

Пары $(d_A, n_A), (d_B, n_B), (d_C, n_C), \ldots$ считаются секретными ключами абонентов $A, B, C, \ldots$

Ключи пользователей в системе RSA

| Абонент | Секретный ключ | Открытый ключ |
|-|-|-|
|$A$|$(d_A, n_A)$|$(e_A, n_A)$|
|$B$|$(d_B, n_B)$|$(e_B, n_B)$|
|$C$|$(d_C, n_C)$|$(e_C, n_C)$|
|$\cdots$|$\cdots$|$\cdots$|

Алгоритм передачи сообщения от $A$ к $B$:
1. Абонент $A$ вычисляет число $S = M^{e_B} \mod n_B$, где $M$ - сообщение ($M < n$), $S$ - шифрованный текст, и передает $S$ абоненту $B$
2. Абонент $B$ получив число $S$ расшифровывает сообщение $S^{d_B} \mod n_B = M$

## 1.3. Шифр Шамира
Пусть абоненты $A$ и $B$ желают вести конфиденциальную переписку

Пусть абонент $A$ выбирает большое простое число $P$ и передает его абоненту $B$. Затем каждый из них выбирает числа, удовлетворяющих условиям:
$$\matrix{A: c_A \cdot d_A = 1 \mod (P - 1) \\ B: c_B \cdot d_B = 1 \mod (P - 1)}$$

При этом при кодировании каждого блока $M_k$ следует выбирать случайные пары $(c_A, d_A)$ и $(c_B, d_B)$ - в противном случае надежность системы понижается

Алгоритм:
1. Абонент $A$ вычисляет число $x_1 = M^{c_A} \mod P$ и пересылает его к абоненту $B$
2. Абонент $B$ получив число $x_1$ вычисляет свое число $x_2 = x_1^{c_B} \mod P$ и передает его абоненту $A$
3. Абонент $A$ получив число $x_2$ вычисляет свое число $x_3 = x_2^{d_A} \mod P$ и передает его абоненту $B$
4. Абонент $B$ получив число $x_3$ вычисляет свое число $x_4 = x_3^{d_B} \mod P = M$, которое равно сообщению, посланное абонентом $A$

# 2. Криптосистема RSA (слабые моменты)
1. Незашифрованные блоки
2. Ключи эквивалентные ключу расшифрования
3. Криптоанализ RSA

Неподвижной (инвариантной) точкой отображения $M^E \mod n$ называется число $M \in \{0, 1, \ldots, n - 1\}$, оставляемое этим отображением на месте, то есть $M^E = M \mod n$

Теорема 1. Число неподвижных точке отображения $M^E \mod n$ равно $d = (d_1 + 1)(d_2 + 1)$, где $d_1 = \gcd(E - 1, p - 1)$ и $d_2 = \gcd(E - 1, q - 1)$

Теорема 2. Количество ключей расшифрования равно $d^* = \gcd(p - 1, q - 1)$

На основании теоремы 2 любое число из множества $\{D + m cdot L(n) \mod \varphi(n), m \in \{0, 1, 2, \ldots, d^* - 1\}\}$, $L(n) = \lcm(p - 1, q - 1)$, $D \cdot E = 1 \mod \varphi(n)$ являются ключом расшифрования

## Криптоанализ криптосистемы RSA
### 1. Метод Ферма
Если делители $p$ и $q$ числа $N$ близки друг к другу

Пусть $p > q$, тогда $N = \left(\frac{p + q}{2}\right)^2 - \left(\frac{p - q}{2}\right)^2$

Пусть $t = \frac{p+q}{2}$, $s = \frac{p - q}{2}$, так как последняя величина небольшая, то и $t - \sqrt N$ также является небольшим числом и $t^2 - N$ является полным квадратом. Переберем все числа $t > \sqrt N$ и проверим на выполнение условия $t^2 - N = a^2$

Далее нахождение $p$ и $q$ не представляет большого труда

### 2. Метод повторного шифрования
Рассмотрим последовательность $y_1 = y = x^e \mod N, y_2 = y_1^e \mod N, \ldots, y_s = y_{s-1}^e \mod N$

Так как $(e, \varphi(N)) = 1$, то $\exists k \in Z, k > 0: e^k = 1 \mod \vdrphi(N)$ и $y_k = y_{k-1}^e = y \mod N$, следовательно $y_{k-1} = x$

### 3. Метод бесключевого чтения
Пусть два пользователя выбрали одинаковый модуль $N$ и разные экспоненты $e_1$ и $e_2$. Третий пользователь посылает им некое циркулярное сообщение $x$, то криптоаналитик может получить в свое распоряжение два шифрованных текста $y_1 = x^{e_1} \mod N$ и $y_2 = x^{e_2} \mod N$

В этом случае криптоаналитик может получить исходное открытое сообщение, используя расширенный алгоритм Евклида, выполнив следующую последовательность действий:
- Находим $r, s$ такие, что $r \cdot e_1 + s \cdot e_2 = 1$
- Получаем открытое сообщение $y_1^r \cdot y_2^s = x^{r\cdot e_1 + s \cdot e_2} = x$

---

09.03.2023

Лекция 5

---

# 3. Криптосистемы основанные на задаче RSA

## Криптосистема Рабина
$P$ и $Q$ - простые числа являются секретным ключом, где $P = Q = 3 \mod 4$

$N = PQ$ - открытый ключ

Правило зашифрования: $y = x^2 \mod N$

Правило расшифрования: $\left\{ \matrix{x_P = \sqrt y \mod P \\ x_Q = \sqrt y \mod Q} \right.$

Из четырех полученных решения одно и будет сообщением $x$

$\{\pm x_P, \pm x_Q\}$

## Криптосистема Уильямса
Формирование ключа

$N = p \cdot q$, $p$ и $q$ - простые числа

$\left\{ \matrix{p \equiv 3 \mod 8 \\ q \equiv 7 \mod 8} \right.$

$e = N$ - открытый ключ

$d = \frac{(p - 1) \cdot (q - 1)}{4} + 1$ - закрытый ключ

Шифрование:
$$\matrix{x^* = \left\{ \matrix{2 \cdot (2 \cdot x + 1), \text{если символ Якоби } \left(\frac{2x + 1}{N}\right) = -1 \\ 4 \cdot (2 \cdot x + 1), \text{если символ Якоби} \left(\frac{2x + 1}{N}\right) = 1} \right. \\ y = \left( x^* \right)^d}$$

Расшифрование:
$$\matrix{x^* = y^2 \mod N \\ x = \left\{ \matrix{\frac{\frac{x^*}{4} - 1}{2}, \text{если} x^* \equiv 0 \mod 4 \\ \frac{\frac{N - x^*}{4} - 1}{2}, \text{если} x^* \equiv 1 \mod 4 \\ \frac{\frac{x^*}{2} - 1}{2}, \text{если} x^* \equiv 2 \mod 4 \\ \frac{\frac{N - x^*}{2} - 1}{2}, \text{если} x^* \equiv 3 \mod 4} \right.}$$

## Криптосистема LUC
Предварительные сведения:

Пусть $a, b \in Z / \{0\}, D = a^2 - 4\ cdot b$, тогда корни уравнения $z^2 - a \cdot z + b = 0$ равны $\alpha = \frac{a + \sqrt D}{2}$ и $\beta = \frac{a - \sqrt D}{2}$

Построим последовательности Люка:

$U_k(a, b) = \frac{\alpha^k - \beta^k}{\alpha - \beta}, U_0(a, b) = 0, U_1(a, b) = 1$

$V_k(a, b) = \alpha^k + \beta^k, V_0(a, b) = 2, V_1(a, b) = a$

$U_k(a, b) = a \cdot U_{k - 1}(a, b) - b \cdot U_{k-2}(a, b), k \geq 2$

$V_k(a, b) = a \cdot V_{k - 1}(a, b) - b \cdot V_{k-2}(a, b), k \geq 2$

Формирование ключа:

$N = p \cdot q$, где $p, q$ - простые числа

$e$ - открытый ключ, где $\gcd(e, (p^2 - 1) \cdot (q^2 - 1)) = 1$

$d$ - закрытый ключ, где $e \cdot d = 1 \mod (p^2 - 1) \cdot (q^2 - 1)$

Шифрование:
$$\matrix{x: \left\{ \matrix{1 < x < N - 1 \\ \gcd(x, N) = 1} \right. \\ y = V_e(x, 1) \mod N}$$

Расшифрование:
$$x = V_d(y, 1) \mod N$$

## Криптосистема Гольдвассера-Микали
Является алгоритмом вероятностного шифрования, так как при шифровании использует псевдослучайные числа

Стойкость алгоритма основывается на вычислительной сложности решения задачи о квадратичном вычете

Формирование ключа:

$p, q$ - простые числа состоящие из $\beta$ бит

$N = p \cdot q$

$z \in Z_N$ - квадратичный не вычет

Тогда $(z, N)$ - открытый ключ, $(p, q)$ - закрытый ключ

Шифрование:

$x \in X$ -  открытое сообщение в виде $x = (x_1, \ldots, x_k), x_j \in \{0, 1\}, j = 1, \ldots, k$

$r_j = Random \in Z_N / \{0\}$

$y_j = \left\{ \matrix{r_j^2 \mod N, \text{если } x_j = 0 \\ z \cdot r_j^2 \mod N, \text{если } x_j = 1} \right.$

$y = (y_1, \ldots, y_k) \in Y$

Расшифрование:

$j = 1, \ldots, k$

Вычисляют символ Лежандра и $x \in X$

$c_j = \left(\frac{y_j}{p}\right)$ и $x_j = \left\{ \matrix{0, \text{если } c_j = 1 \\ 1, \text{в противном случае}} \right.$

Таким образом

$x_j = 0$, если $y_j$ квадратичный вычет

$x_j = 1$ в противном случае

$x$ - открытое сообщение

## Криптосистема RSA на эллиптических кривых
Формирование ключа

$N = p \cdot q$

$a, b \in Z$ такие, что $E_N(a, b): y^2 = x^3 + ax + b$ определяет эллиптическую кривую как в поле $Z_p$ так и в поле $Z_q$

$N_1 = \lcm(\#(E_p(a, b)), \#(E_q(a, b)))$

$(e, N)$ - открытый ключ и $\gcd(e, N_1) = 1$

$(d, p, q, N_1)$ - закрытый ключ, где $e \cdot d = 1 \mod N_1$

Шифрование:

$x \in X$ - открытое сообщение

$M$ - точка на $E_N(a, b)$ кодирующая $x$

$y = e \cdot M \mod N$ - шифрованный текст

Расшифрование:

$M = d \cdot y \mod N$

Открытый текст $x$ восстанавливается из $M$

# 4. Криптосистема Эль-Гамаля
## Криптосистема Эль-Гамаля над простым полем
Формирование ключа:

$p$ - большое простое число

$g$ - образующий элемент $F_p^*$

$(p, g)$ - открытые параметры

$a = Random \in \{2, \ldots, p - 1\}$ - закрытый ключ

$g^a \in F_p^*$ - открытый ключ

Шифрование:

$r \in Random \in F_p^*$

$x \in X$

$y = (g^r, x \cdot k^r) \in F_p^* \times F_p^*$

Расшифрование:

$(x \cdot k^r) \cdot ((g^r)^a)^{-1} = x \in X$

# Алгоритм на основе задачи об укладке ранца
В 1978 году Меркль и Хеллман предложили использовать задачу об укладке ранца (рюкзака) для ассиметричного шифрования. Она относится к классу NP-полных задач и формулируется следующим образом. Дано множество предметов различного веса. Спрашивается, можно ли положить некоторые из этих предметов в ранец так, чтобы его вес стал равен определенному значению?

Более формально задача формулируется так:
- Дан набор значений $M_1, M_2, \ldots, M_n$ и суммарное значение $S$
- Требуется вычислить значения $b_i$ такие что $S = b_1M_1 + b_2M_2 + \ldots + b_nM_n$, где $n$ - количество предметов, $b_i$ - бинарный множитель и значение $b_i = 1$ означает, что предмет $i$ кладут в рюкзак, а $b_i = 0$ - не кладут

В основе алгоритма, предложенного Мерклом и Хеллманом, лежит идея шифрования на основе решения серии задач укладки ранца. Предметы из кучи выбираются с помощью блока открытого текста, длина которого (в битах) равна количеству предметов в куче. При этом биты открытого текста соответствуют значениям $b$, а шифртекст является полученным суммарным весом.

Пример шифрования на основе задачи об укладке ранца:

| Открытый текст | $11100100$ | $01011001$ | $00000000$ |
|-|-|-|-|
| Ключ | $1$ $5$ $6$ $11$ $14$ $20$ $32$ $43$ | $1$ $5$ $6$ $11$ $14$ $20$ $32$ $43$ | $1$ $5$ $6$ $11$ $14$ $20$ $32$ $43$ |
| Криптограмма | $32 = 1 + 5 + 6 + 20$ | $73 = 5 + 11 + 14 + 43$ | $0$ |

На самом деле существует две различные проблемы рюкзака, одна решается за линейное время, а другая, как считается, - нет. Легкую проблему можно превратить в трудную. Открытый ключ представляет собой трудную проблему, которую легко использовать для шифрования, но невозможно для расшифрования сообщений. Закрытый ключ является легкой проблемой, давая простой способ расшифровать сообщение. Тому, кто не знает закрытый ключ, придется попытаться решить трудную проблему рюкзака.

## Сверхвозрастающие рюкзаки
Что такое легкая проблема рюкзака? Если перечень масс представляет собой свервозрастающую последовательность, то полученную проблему рюкзака легко решить.

Сверхвозрастающая последовательность - это последовательность, в которой каждый член больше суммы всех предыдущих членов.

Например, последовательность $\{1, 3, 6, 13, 27, 52\}$ - сверхвозрастающая, а $\{1, 3, 4, 9, 15, 25\}$ - нет

Решение сверхвозрастающего рюкзака найти легко. Возьмем полный вес и сравним его с последним большим числом последовательности. Если полный вес меньше, чем это число, то его не кладут в рюкзак. Если полный вес больше или равен этому числу, то оно кладется в рюкзак. Уменьшим массу рюкзака на это значение и перейдем к следующему по величине числу последовательности. Будем повторять, пока процесс не закончится. Если полный вес уменьшиться до нуля, то решение найдено. В противном случае нет.

Не сверхвозрастающие, или нормальные, рюкзаки представляют собой трудную проблему - быстрого алгоритма для них не найдено.

## Создание открытого ключа из закрытого
Чтобы получить нормальную последовательность рюкзака, возьмем сверхвозрастающую последовательность рюкзака и умножим по модулю $m$ все значения на число $n$. Значения модуля должно быть больше суммы всех чисел последовательности. Множитель должен быть взаимно простым числом с модулем.

Сверхвозрастающая последовательность рюкзака является закрытым ключом, а нормальная последовательность рюкзака - открытым.

## Шифрование
Для шифрования сообщение сначала разбивается на блоки, равные по длине числу элементов последовательности рюкзака. Затем, считая, что единица указывается на присутствие члена последовательности, а ноль - на его отсутствие, вычисляем полные веса рюкзаков - по одному для каждого блока сообщения.

## Расшифрование
Законный получатель данного сообщения знает закрытый ключ: оригинальную сверхвозрастающую последовательность, а также значения $n$ и $m$, использованные для превращения ее в нормальную последовательность рюкзака. Для расшифрования сообщения получатель должен сначала определить $n^{-1}$, такое что $n(n^{-1}) \equiv 1 \mod m$. Каждое значение шифротекста умножается на $n^{-1} \mod m$, а затем разделяется с помощью закрытого ключа, чтобы получить значения открытого текста.

## Практические реализации
Реальные рюкзаки должны содержать не менее 250 элементов. Длина каждого члена сверхвозрастающей последовательности должна быть между 200 и 400 битами, а длина модуля должна быть от 100 до 200 битов.
