19.10.2023

Лекция 4

---

Различают следующие типы протоколов распределения ключей:
- Протоколы передачи (уже сгенерирвоанных)
- Протоколы (совместной) выработки общего ключа (открытое распределение ключей)
- Схемы предварительного распределения ключей

Различают также протоколы распределения ключей между отдельными участниками и между группами участников информационного взаимодействия

Начем рассмотрение протоколв передачи ключей. При этом считаем, что эти ключи уже были заранее сгенерированы кем-либо из участников протокола

# 1. Передача ключей с использованием симметричного шифрования
Имеются протоколы, в которых стороны осуществляют передачу ключей при непосредственном взаимодействии, то есть двусторонние протоколы или, иначе, протоколы типа "точка-точка" и протоколы с централизованным распределением ключей, в которых предусмотрена третья сторона, играющая роль доверенного центра

## 1.1. Двусторонние протоколы
Пусть стороны $A$ и $B$ заранее обладают общей секретной информацией. Допустим, что это секретный ключ $k_{AB}$. Тогда для передачи ключа $k$ стороны могут использовать одностороннюю передачу:
$$A \rightarrow B: E_{k_{AB}}(k, t, B)$$
где $E$ - алгоритм шифрования, $t$ - метка времени, $B$ - идентификатор участника

Если не передавать метки времени, то злоумышленник может осуществить повторную передачу того же сообщения. Если же не указывать идентификатор адресата, то злоумышленник может вернуть отправителю перехваченное сообщение, что в некоторых ситуациях может быть опасным, поскольку абонент не сможет установить, что это сообщение получено не от абонента $B$. заметим также, что временная метка и идентификатор могут служить дополнительным подтверждением правильности источника, так как соответствие форматов этих полей после их расшифрования принятым в системе свидетельствует о том, что зашифрование мог осуществить только $A$

В приведенном протоколе вместо шифрования можно было использовать ключевую хеш-функцию, зависящую от общего ключа
$$A \rightarrow B: k+h_{k_{AB}}(t, B, R), R$$
однако здесь теряется возможность проверки правильности формата и, тем самым, подтверждение правильности получения ключа можно будет осуществить только после дополнительного обмена сообщениями

Если предъявить к протоколу требование проведения аутентификации сеанса с целью более надежной аутентификации источника и подтверждения единственности и своевременности передачи сообщений для защиты от повторной передачи, то можно использовать следующий протокол типа "запрос-ответ":
1. $B \rightarrow A: R_B$
2. $A \rightarrow B: E_{k_{AB}}(k, R_B, B)$

При использовании хеш-функции подобный протокол может выглядеть так:
1. $B \rightarrow A: R_B$
2. $A \rightarrow B: k+h_{k_{AB}}(R_B, B)$

Исходный протокол можно модифицировать так, чтобы искомый ключ $k$ генерировался не одной стороной, а являлся результатом двустороннего обмена. Пусть участниками помимо случайных чисел $R_A$ и $R_B$ генерируются также случайный числа $k_A$ и $k_B$ соответственно

Тогда в результате выполнения протокола
1. $B \rightarrow A: R_B$
2. $A \rightarrow B: E_{k_{AB}}(k_A, R_A, R_B, B)$
3. $B \rightarrow A: E_{k_{AB}}(k_B, R_B, R_A, A)$

Каждая из сторон может вычислить общий ключ $k$ с помощью некоторой функции $f$ по правилу $k = f(k_A, k_B)$. Подчеркнем, что в этом протоколе ни одна из сторон не может предсказать заранее значения ключа $k$

### Протокол Andrew RPC Handshake
Протокол рукопожатия для процедур удаленного вызова

Болеe сложный пример двустороннего протокола передачи ключа, предложенный в 1987 году

1. $A \rightarrow B: A, E_{k_{AB}}(r_A)$
2. $A \leftarrow B: E_{k_{AB}}(r_A + 1, r_B)$
3. $A \rightarrow B: E_{k_{AB}}(r_B + 1)$
4. $A \leftarrow B: E_{k_{AB}}(k, r'_B)$

Здесь первые три сообщения реализуют взаимную аутентификацию сторон, а четвертое - передачу ключа, причем эти две части протокола никак не связаны между собой

Недостаток: поскольку в четвертом сообщении нет никаких средств для проверки новизны ключа, то нарушитель может повторно передать последнее сообщение из старого протокола в новом, и поэтому $A$ будет использовать старое значение ключа из прошлого протокола

Исправленный вариант:
1. $A \rightarrow B: A, R_A$
2. $A \leftarrow B: E_{k_{AB}}(R_A + 1, k)$
3. $A \rightarrow B: E_{k}(R_A + 1)$
4. $A \leftarrow B: R_B^*$

В 1996 предложена атака на этот протокол, позволяющий нарушителю $C$ выступать от имени $B$, который при этом вообще не учавствует в обмене. Для этого нарушитель $C$ перехватывает все сообщения, отправляемые от $A$ к $B$, и открывает дополнительную параллельную сессию с $A$ от имени $B$, где полностью повторяет передаваемые $A$ сообщения:
1. $A \rightarrow C(B): A, r_A$
2. $A \leftarrow C(B): B, r_A$
3. $A \rightarrow C(B): E_{k_{AB}}(r_A + 1, k)$
4. $A \leftarrow C(B): E_{k_{AB}}(r_A + 1, k)$
5. $A \rightarrow C(B): E_k(r_A + 1)$
6. $A \leftarrow C(B): E_k(r_A + 1)$
7. $A \rightarrow C(B): r'_B$
8. $A \leftarrow C(B): r'_B$

В результате $A$ будем думать, что он работает с $B$, в то время как сам $B$ вообще не будет ни о чем догадываться

### Использование односторонней функции
В этом протоколе участник $A$ иметт право самостоятельно генерировать новый сеансовый ключ $k$. Получив сообщение на шаге (2), $B$ расшифровывает его и проверяет правильность полученного значения $f(r_B)$. Затем он вычисляет проверочное значение $f(r_A)$, и отправляет его $A$, зашифровав на новом ключе $k$. Теперь $A$ проверяет правильность значения $f(r_B)$ и убеждается в целостности сеанса и подлинности $B$
1. $A \leftarrow B: B, r_B$
2. $A \rightarrow B: A, E_{k_{AB}}(f(r_B), r_A, A, k)$
3. $A \leftarrow B: B, E_k(f(r_A))$

### Бесключевой протокол А. Шамира
Рассмотрим протокол, позволяющий передать ключ без использования какой-либо общей секретной информации. Этот протокол иногда называют трехпроходным протоколм Шамира-Ривеста-Адлемана

Пусть имеется некоторое коммутирующее шифрующее преобразование $E$. Это означает, что при всех сообщениях $x$ и произвольных ключах $k_1$ и $k_2$ выполняется равенство
$$E_{k_1}(E_{k_2}(x)) = E_{k_2}(E_{k_1}(x))$$

Тогда пользователи $A$ и $B$ могут реализовать следующий трехпроходный протокол для передачи секретного ключа $k$ от $A$ к $B$:
1. $A \rightarrow B: E_{k_A}(k)$
2. $A \leftarrow B: E_{k_B}(e_{k_A}(k))$
3. $A \rightarrow B: D_{k_A}(E_{k_B}(E_{k_A}(k))) = E_{k_B}(k)$

Заметим, что в этом протоколе можно использовать не каждое коммутирующее преобразование $E$. Например, легко видеть, что для преобразования $E_{k_A}(k) = k + \Gamma \mod 2$ протокол оказывается заведомо нестойким. Поэтому в протоколе Шамира рекомендуется использовать преобразование вида $E_{k_A}(k) = k^a \mod p$, в котором константа $a$ определяется ключом $k_A$, а $p$ - большое простое число

## 1.2. Трехсторонние протоколы
Рассмотрим протоколы передачи ключей между парами участников с использованием доверенной третьей стороны $T$, называемой центром. В этом качестве обычно выступает некоторый выделенный узел сети, или сервер, которому доверяют все участники. Центр $T$ хранит ключи всех абонентов сети. Поэтому схема ключевых взаимоотношений графически представляет собой звезду

### Протокол Wide-Mouth Frog
1. $A \rightarrow T: A, E_{k_{AT}}(t_A, B, k)$
2. $T \rightarrow B: E_{k_{BT}}(t_T, A, k)$

Здес центр $T$ выступает как центр перешифрования клбчей, $k_{AT}$ и $k_{BT}$ - ключи, применяемые для связи цчастника $A$ с центром $T$ и участника $B$ с центром $T$ соответственно

Простейшая атака на этот протокол состоит в повторной передаче центру $T$ сообщения (1), в подходящем временном интервале, что вызывает ответное сообщение с новой меткой времени

Более сложная атака состоит в записи всего сеанса и последующем использовании центра $T$ для получения нужных сообщений

1. $A \rightarrow T: A, E_{k_{AT}}(t_A, B, k)$
2. $T \rightarrow B: E_{k_{BT}}(t_T, A, k)$
3. $C(B) \rightarrow T: B, E_{K_{BT}}(t_T, A, k)$
4. $T \rightarrow C(A): E_{k_{AT}}(t'_T, B, k)$
5. $C(A) \rightarrow T: A, E_{k_{AT}}(t'_T, B, k)$
6. $T \rightarrow C(B): E_{k_{BT}}(t''_T, A, k)$

Теперь $C$ может подменять центр и отвечать на подходящие сообщения от $A$ к $B$:
1. $A \rightarrow C(T): A, E_{k_{AT}}(t'_T, B, k)$
2. $C(T) \rightarrow B: E_{k_{BT}}(t''_T, A, k)$

### Протокол Yaholom
В данном протоколе центр $T$ выступает как центр генерации и распределения ключей. Пусть как и выше $k_{AT}$ и $k_{BT}$ - ключи, применяемые для связи участника $A$ с центром $T$ и участника $B$ с центром $T$ соответственно

1. $A \rightarrow B: A, r_A$
2. $B \rightarrow T: B, E_{k_{BT}}(A, r_A, r_B)$
3. $T \rightarrow T: t_a = E_{k_{AT}}(B, k, r_A, r_B), t_B = E_{k_{BT}}(A, k)$
4. $A \rightarrow B: t_B, E_k(r_B)$

Слабость этого протокола в том, что в последнем сообщении протокола нет никаких средств для проверки своевременности получения ключа. Поэтому это сообщение можно использовать для навязывания старого ключа, что особенно опасно в случае его компроментации. Этот недостаток был исправлен

Предложен следующий исправленный вариант протокола - протокол BAN-Yahalom
1. $A \rightarrow B: A, r_A$
2. $B \rightarrow T: B, r_B, E_{k_{BT}}(A, r_A)$
3. $T \rightarrow A: r_B, t_A = E_{k_{AT}}(B, k, r_A), t_B = E_{k_{BT}}(A, k, r_B)$
4. $A \rightarrow B: t_B, E_k(r_B)$

Для этого протокола также была найдена следующая атака (interleaving replay attack):
1. $C(A) \rightarrow B: A, r_A$
2. $B \rightarrow C(T): B, r_B, E_{k_{BT}}(A, r_A)$
3. $C(A) \rightarrow B: A, r_A, r_B$
4. $B \rightarrow C(T): B, r'_B, E_{k_{BT}}(A, r_A, r_B)$
5. $C(T) \rightarrow C(A):$ пропущен
6. $C(A) \rightarrow B: E_{k_{BT}}(B, k=r_A, r_B), E_k(r_B)$
