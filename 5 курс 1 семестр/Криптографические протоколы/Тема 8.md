26.10.2023

Лекция 5

---

# Протокол Woo-Lam взаимной аутентификации и распределения ключей

Этот протокол осуществляет распределение ключей и взаимную аутентификацию с использованием симметричного шифрования

1. $A \rightarrow B: A, r_A$
2. $A \leftarrow B: B, r_B$
3. $A \rightarrow B: E_{k_(AT)}(A, B, r_A, r_B)$
4. $B \rightarrow T: E_{k_{AT}}(A, B, r_A, r_B), E_{k_{BT}}(A, B, r_A, r_B)$
5. $B \leftarrow T: E_{k_{AT}}(B, r_A, r_B, k), E_{k_{BT}}(A, r_A, r_B, k)$
6. $A \leftarrow B: E_{k_{AT}}(B, r_A, r_B, k), E_k(r_A, r_B)$
7. $A \rightarrow B: E_k(r_B)$

Атака:

1. $A \rightarrow B: A, r_1$
2. $A \leftarrow B: B, r_1$
3. $A \rightarrow B: A, r_2$
4. $A \leftarrow B: B, r_2$
5. $A \rightarrow B: E_{k_{AT}}(A, B, r_1, r_2)$
6. $B \rightarrow T: E_{k_{AT}}(A, B, r_1, r_2), E_{k_{BT}}(A, B, r_1, r_2)$
7. $B \leftarrow T: E_{k_{AT}}(B, r_1, r_2, k), E_{k_{BT}}(A, r_1, r_2, k)$
8. $A \leftarrow B: E_{k_{AT}}(B, r_1, r_2B, k), E_k(r_1, r_2)$
9. $A \rightarrow B: E_k(r_2)$
10. $A \leftarrow B: E_{k_{AT}}(A, B, r_1, r_2)$
11. $A \rightarrow B(T): E_{k_{AT}}(A, B, r_1, r_2), E_{k_{BT}}(A, B, r_1, r_2)$
12. $A \leftarrow B(T): E_{k_{AT}}(B, r_1, r_2, k), E_{k_{BT}}(A, r_1, r_2, k)$
13. $A \rightarrow B: E_{k_{AT}}(B, r_1, r_2B, k), E_k(r_1, r_2)$
14. $A \leftarrow B: E_k(r_2)$

Нарушитель B открывает второй сеанс с A, повторяя все случайные значения из первого сеанса. Затем он завершает первый сеанс, сохраняя все его сообщения, после этого он перехватывает сообщения от участника A к серверу T и возвращает участнику A сообщения и первого сеанса в обратном порядке. В результате участник A примет вторично ключ k.

## Протокол NS

Один из первых протоколов такого типа был предложен Нидхэмом и Шредером (Needham - Schroeder). Он заключается в выполнении следующих шагов:

1. $T \leftarrow A: A, B, r_A$
2. $T \rightarrow A: E_{k_{AT}}(r_A, B, k, E_{k_{bT}}(k, A))$
3. $A \rightarrow B: E_{k_{BT}}(k, A)$
4. $A \leftarrow B: E_k(r_B)$
5. $A \rightarrow B: E_k(r_B - 1)$

В результате выполнения шагов 1-3 протокола пользователи и получают сгенерированный центром общий ключ $k$ для организации взаимодействия. Шаги 4 и 5 предназначены для аутентификации пользователя и подтверждения правильности получения ключа обеими сторонами

В 1981 году в работе Дэннинг (Denning) и Сакко (Sacco) была обнаружена слабость этого протокола, заключающаяся в возможности повторной передачи абоненту сообщения, переданного на шаге 3. При таком повторе абонент не имеет возможности установить, что полученный ключ $k$ уже был использован. Поэтому в случае компрометации этого ключа злоумышленник может аутентифицироваться и передавать сообщения от имени A

## Протокол Denning-Sacco

Предложенный Дэннинг и Сакко в качестве одного из вариантов улучшения протокола NS, основан на использовании метки времени:

1. $T \leftarrow A: A, B$
2. $T \rightarrow A: E_{k_{AT}}(B, k, t, E_{k_{BT}}(A, k, t))$
3. $A \rightarrow B: E_{k_{BT}}(A, k, t)$

Теперь B может сравнить метку времени из третьего сообщения с показанием своих часов и убедиться в том, что это сообщение является новым. Протокол выполняется за три прохода, так как шаги 4 и 5 теперь не нужны

## Протокол NS (исправленный)

В 1987 году Нидхэм и Шредер предложили новую исправленную версию своего протокола, добавив в начале два дополнительных шага:

1. $A \rightarrow B: A$
2. $A \leftarrow B: E_{k_{BT}}(A, r_B)$
3. $T \leftarrow A: A, B, r_A, E_{k_{BT}}(A, r_B)$
4. $T \rightarrow A: r_A, B, k, E_{k_{BT}}(k, r_B, A)$
5. $A \rightarrow B: E_{k_{BT}}(k, r_B, A)$
6. $A \leftarrow B: E_k(n_0)$
7. $A \rightarrow B: E_k(n_0 - 1)$

Позже в 2005 году Лонг (Long) нашел атаку и на этот вариант протокола, заключающуюся в подмене типов полей в сообщениях протокола (type flaw). Она проходит в случае, когда возможно сделать идентификатор участника C, выступающего в роли нарушителя, так, что его длина будет равна суммарной длине полей $(r_A, B, k)$. Атака осуществляется вначале путем перехвата открытия после третьего шага дополнительного сеанса, в котором нарушитель C выступает и от имени участника B и от имени сервера T

1. $A \rightarrow C(B): A$
2. $A \leftarrow C(B): X$
3. $C(T) \leftarrow A: A, B, r_A, X$
4. $A \leftarrow C(B): C = (r_A, B, k')$
5. $A \rightarrow C(B): E_{k_{AT}}(C, r'_A)$
6. $C(T) \rightarrow A: E_{k_{AT}}((r_A, B, k'), r'_A)$
7. $A \rightarrow C(B): r'_A$
8. $A \leftarrow C(B): E_{k'}(n_0)$
9. $A \rightarrow C(B): E_{k'}(n_0 - 1)$

Здесь $X$ - произвольное сообщение формата $E_{k_{BT}}(A, r_B)$, формируемое нарушителем в качестве отклика на шаге 2 (он не знает ключа $k_{BT}$). Если участник A сразу отправит его серверу T, не пробуя его расшифровать и не проводя сравнение идентификатора, то далее нарушитель открывает второй сеанс от имени B. Полученное от A значение $E_{k_{AT}}(C, r'_A)$ интерпретируется нарушителем как $E_{k_{AT}}(r_A, B, k', r'_A)$ и возвращается им обратно участнику A. Участник A, расшифровывает его и извлекает значение $r'_A$, полагая, что это $E_{k_{BT}}(A, r'_B)$. Не имея возможности расшифровать и проверить его, так как он не знает ключа $k_{BT}$, он перенаправляет его участник B. Теперь нарушитель знает ключ $k'$ и поэтому он может нормально завершить сеанс с A от имени B. В резульате участник A уверен, что взаимодействует с участником B, а B при этом ничего не подозревает

## Протокол Kerberos

Другой подход к устранению недостатка протокола NS использован в протоколе Kerberos, который в настоящее время получил широкое распространение. Рассмотрим сначала базовый протокол, применяемый в протоколе аутентификации и распределения ключей Kerberos

Он состоит из следующих шагов:

1. $A \rightarrow T: A, B, r_A$
2. $A \leftarrow T: E_{k_{AT}}(k, r_A, L, B)$, билет
3. $A \rightarrow B:$ билет, аутентификатор
4. $A \leftarrow B: E_k(t, k_B)$

Здесь билетом названа величина $E_{k_{BT}}(k, A, L)$, аутентификатором - величина $E_k(A, t, k_A)$, $t$ - метка времени, $L$ - период времени действия билета, $r_A$ - случайное число, сгенерированное участником и вставленное в передаваемое сообщение для взаимной аутентификации, а $k_A$ и $k_B$ - случайные числа, сгенерированные абонентами A и B соответственно и используемые в качестве ключа шифрования информации другой стороне, либо для выработки общего ключа $k_{AB} = f(k_A, k_B)$ с помощью некоторой функции $f$

В полном протоколе Kerberos описанный выше базовый протокол используется два раза. Дело в том что в нем предусмотрено два сервера

Первый - сервер аутентификации, обозначаемый AS, выдает так называемые "билеты для получения билетов" (tgt), содержащие ключи, предназначенные для длительного использования. Второй сервер, TGS - сервер выдачи билетов, выдает обычные билеты для доступа к сетевым ресурсам и обращения к другим пользователям

Сообщения, передаваемые согласно этому протоколу, выглядят следующим образом:

1. $A \rightarrow AS: A, TGS, r_A$
2. $A \leftarrow AS: E_{k_{A, AS}}(k_{A, TGS}r_A, L_1, TGS), tgt$, аутентификатор$_1$
3. $A \rightarrow TGS: E_{k_{A, TGS}}(k, r'_A, L_2, B)$, билет
4. $A \rightarrow B:$ билет, аутентификатор$_2$
5. $A \leftarrow B: E_k(t_2, k_B)$

где $tgt = E_{k_{AS, TGS}}(k_{A, TGS}, A, L_1)$, аутентификатор$_1$ = $E_{k_{A, TGS}}(A, t_1, r'_A)$, билет = $E_{k_{B, TGS}}(k, A, L_2)$, аутентификатор$_2$ = $E_k(A, t_2, k_A)$

Благодаря введению второго сервера нагрузка на первый серве уменьшается во много раз. Первый сервер должен быть наиболее защищенным, поскольку он хранит главные ключи всех пользователей. Серверов второго типа может быть несколько, и они могут соответствовать определенной подсети или определенному типу ресурса

# Передача ключей с использованием ассиметричного шифрования

## Протоколы без использование цифровой подписи

Для передачи ключа $k$ можно использовать следующий одношаговый протокол:

1. $A \rightarrow B: E_B(k, t, A)$

где $E_B$ - алгоритм шифрования с открытым ключом участника B, $t$ - метка времени

### Протокол NSPK

1. $A \rightarrow B: E_B(k_A, A)$
2. $A \leftarrow B: E_A(k_A, k_B)$
3. $A \rightarrow B: E_B(k_B)$

### Протокол Woo-Lam

Участниками протокола являются абоненты A и B, а также центр генерации ключей - доверенный сервер T. Каждый из участников имеет пару ключей асимметричного алгоритм шифрования, заверенную сертификаторм открытого ключа.

Протокол состоит из следующих шагов:

1. $A \rightarrow B: E_B(r_A, A)$
2. $B \rightarrow T: B, A, E_T(r_A)$
3. $B \leftarrow T: E_B(D_T(r_A, k_{AB}, B))$
4. $A \leftarrow B: E_A(D_T(r_A, k_{AB}, B), r_B)$

где $E_i$ - операция зашифрования данных на открытом ключе участника $i$, $D_T$ - операция расшифрования данных на ассиметричном секретном ключе доверенного сервера $T$, $E_{k_{AB}}$ - операция зашифрования данных симметричным криптографическим алгоритмом на ключе $k_{AB}$. Здесь $k_{AB}$ - порождаемый доверенным сервером $T$ результирующий ключ, $r_A$ и $r_B$ - случайные числа, порождаемые соответственно абонентами $A$ и $B$

Атака:

1. $A \rightarrow B: E_B(r_A, A)$
2. $B \rightarrow C(T): B, A, D_T(r_A)$
3. $C \rightarrow T: C, U, E_T(r_A)$
4. $C \leftarrow T: E_C(D_T(r_A, k_{CU}, C))$
5. $B \leftarrow C: E_B(r_A, C)$
6. $T \leftarrow B: B, C, E_T(r_A)$
7. $T \rightarrow B: E_B(D_T(r_A, k_{CB}, B))$
8. $B \rightarrow C: E_C(D_T(r_A, k_{CB}, B), r'_B)$
9. $B \leftarrow C(T): E_B(D_T(r_A, k_{CB}, B))$

## Протоколы с использованием цифровой подписи

При использовании цифровой подписи аутентифицированный протокол передачи ключей может содержать только одно сообщение и иметь, например, один из следующих трех видов

- Зашифрование и подпись ключа $A \rightarrow B: E_B(k, t), Sig_A(B, k, t)$
- Зашифрование подписанного ключа $A \rightarrow B: E_B(k, t, Sig_A(B, k, t))$
- Подпись зашифрованного ключа $A \rightarrow B: t, E_B(A, k), Sig_A(B, t, E_B(A, k))$

## Сертификаты открытых ключей

Многие протоколы и приложения, использующие криптосистемы с открытыми ключами для широкого спектра задач, должны быть способны работать с большим числом открытых ключей, применяемых в распределенных системах. Поэтому им приходится обращаться к услугам инфраструктуры открытых ключей (public key infrastructures, PKI), которые предназначены для управления открытыми ключами для различных приложений. Большинство инфраструктур открытых ключей основаны на центрах сертификации (certification authorities, CAs), которые выдают сертификаты. Точнее, они осуществляют проверку и подтверждение подлинности открытых ключей. Как правило, при использовании открытых ключей, хранятся не сами ключи, а их сертификаты. Центры сертификации подписывают сертификаты и ведут списки отозванных сертификатов (certificate revocation lists, CRLs)

Примерами PKI являются PKIX (Public-Key Infrastructure X.509), SPKI (Simple Public Key Infrastructure) и DNSSEC (Domain Name System Security), которые стандартизированы сообществом IETF

Сертификат представляет собой набор данных

$$cert_A = (A, k_A, t, Sig_T(A, k_A, T))$$

состоящий из идентификатора абонента A, его открытого ключа $k_A$ и дополнительной информации, включающей время $t$ выдачи сертификата, срок его действия, предназначение ключа и так далее, заверенный цифровой подписью доверенного центра T или заслуживающего доверия лица

Сертификат предназначен для исключения возможности подмены открытого ключа при его хранении или пересылке. Получив такой сертификат и проверив цифровую подпись, можно убедиться в том, что открытый ключ едйствительно принадлежит данному абоненту

Международный стандарт MKKTT X.509 (Comite Concsultatif Telegraphique Telephonique) определяет следующий протокол аутентификации с одновременным распределением ключей:

1. $A \rightarrow B: cert_A, d_A, Sig_A(d_A)$
2. $A \leftarrow B: cert_B, d_B, Sig_B(d_B)$
3. $A \rightarrow B: r_B, B, Sig_A(r_B, B)$

Где $cert_A$ и $cert_B$ - сертификаты сторон, $Sig_A$ и $Sig_B$ - цифровые подписи сторон, $d_A = (t_A, r_A, B, data_1, E_B(k_A))$, $d_B = (t_B, r_B, A, data_2, E_A(k_B))$ - наборы передаваемых и подписываемых данных. В поле $data$ заносится дополнительная информация для аутентификации источника
